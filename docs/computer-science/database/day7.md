# Day 7: 면접 대비 & 실무 활용 팁

- **면접 대비 핵심 키워드**
  - SQL 최적화, 인덱스 설계, 정규화/반정규화
  - 트랜잭션 격리와 동시성 문제
- **DB 트러블슈팅 시나리오**
  - 쿼리 성능 저하 분석
  - 락 경합 및 데드락 사례
- **실무 응용 전략**
  - 대규모 트래픽 환경에서 DB 설계 시 고려 사항
  - 마이크로서비스 아키텍처(DB 분산, 데이터 동기화)
  - 모니터링 툴 & 로깅(메트릭 수집, 알림 시스템)

---

## 1. 면접 대비 핵심 키워드

### 1.1 SQL 최적화 & 인덱스 설계

- **SQL 쿼리 튜닝**:
  - JOIN 순서, WHERE 절 인덱스 활용, GROUP BY·ORDER BY 시 정렬 비용 최소화 등
  - `EXPLAIN`, `QUERY PLAN` 등을 통해 실행 계획을 분석하고, 불필요한 풀 스캔(Full Table Scan)을 피하는 방식
- **인덱스 설계**:
  - 자주 사용되는 검색·조인 컬럼에 인덱스 적용
  - 다중열 인덱스 시, 컬럼 순서 주의(Leftmost Prefix Rule)
  - 지나친 인덱스 남발은 쓰기 성능 저하 초래

### 1.2 정규화와 반정규화

- **정규화**:
  - 데이터 중복·이상현상 최소화, 테이블 구조를 논리적·체계적으로 분할
  - 1NF → 2NF → 3NF → BCNF 순으로 단계별 검토
- **반정규화**:
  - 조회 성능을 위해, 일부 중복 저장이나 테이블 병합 등을 통해 조인 부담 감소
  - 과도한 반정규화는 데이터 불일치 위험 증가, 신중히 적용

### 1.3 트랜잭션 격리와 동시성 문제

- **트랜잭션 격리 수준** (READ COMMITTED, REPEATABLE READ, SERIALIZABLE 등)
  - 각각 어떤 이상현상(Dirty Read, Non-Repeatable Read, Phantom Read)을 방지하는지 묻는 경우가 많음
- **동시성 문제**
  - Locking 기법(Shared/Exclusive Lock), MVCC 등
  - 데드락(Deadlock) 사례와 해결 전략(회피/탐지/복구)

---

## 2. DB 트러블슈팅 시나리오

### 2.1 쿼리 성능 저하 분석

1. **증상 파악**:
   - 특정 쿼리가 갑자기 느려짐, 응답 지연이 급증
   - CPU·메모리·디스크 IO 모니터링에서 스파이크 확인
2. **원인 진단**:
   - 실행 계획(EXPLAIN) 확인, 테이블 풀 스캔 발생 여부
   - 인덱스 유실(삭제·오류) 또는 통계 정보(old statistics)로 옵티마이저가 잘못된 플랜 선택
   - 많은 수의 조인, 복잡한 서브쿼리 등
3. **해결**:
   - 인덱스 재생성/추가, 통계 갱신(ANALYZE)
   - 쿼리 리팩토링(JOIN 구조 변경, 서브쿼리 대신 JOIN, UNION vs UNION ALL 차이 등)
   - 파티셔닝이나 캐싱 도입

### 2.2 락 경합 및 데드락 사례

1. **락 경합(Lock Contention)**
   - 특정 행 또는 테이블에 배타 락이 오래 걸려, 다른 트랜잭션 대기
   - 트랜잭션이 길어질수록 잠금 유지 시간이 증가, 전체 성능 저하
2. **데드락(Deadlock)**
   - 두 트랜잭션이 서로가 가진 락을 기다리며 무한 대기
   - DBMS에서 자동 감지 후, 트랜잭션 하나를 롤백하는 경우가 많음
3. **해결**
   - 트랜잭션 크기를 작게 유지, 락 범위를 최소화
   - 트랜잭션 순서(획득 순서)를 일관되게 정의
   - 재시도 로직(어플리케이션 레벨)을 구현

---

## 3. 실무 응용 전략

### 3.1 대규모 트래픽 환경에서 DB 설계 시 고려 사항

1. **스케일링 전략**
   - **수직 확장(Scale-Up)**: 고성능 서버로 교체 (비용↑, 한계 존재)
   - **수평 확장(Scale-Out)**: 샤딩(Sharding), 레플리케이션(Replication) 활용
2. **캐싱(Caching)**
   - 자주 조회되는 데이터(예: 상품 목록, 세션) Redis 등 메모리 DB로 캐싱
   - DB 부하를 줄이고 응답 시간을 단축
3. **데이터 아카이빙(Archiving)**
   - 오래된 데이터는 별도 아카이브 테이블/서버로 옮겨, 운영 DB에 쌓이지 않도록 함
   - 파티셔닝(Partitioning) 기능으로 날짜 단위 분할

### 3.2 마이크로서비스 아키텍처(DB 분산, 데이터 동기화)

1. **각 서비스별 DB 분리**
   - 서비스 간 결합도를 낮춰, 장애나 변경 범위 최소화
   - 중간 통신은 API나 메시지 큐 등을 통해 이루어짐
2. **데이터 동기화**
   - 분산 DB 간 Eventually Consistency를 허용할지, Sagas 패턴 등 분산 트랜잭션 보상 로직을 쓸지 결정
   - 한 시스템 변경 시 다른 시스템에도 이벤트로 전달
3. **폴리글랏 퍼시스턴스(Polyglot Persistence)**
   - 서비스 특성별로 서로 다른 데이터베이스(RDB, NoSQL, 시계열 DB 등)를 혼합 사용

### 3.3 모니터링 툴 & 로깅(메트릭 수집, 알림 시스템)

1. **모니터링 도구**
   - 데이터베이스 전용 모니터링(New Relic, Datadog, Percona Monitoring 등)
   - 성능 지표(QPS, Latency, Lock Time, Buffer Hit Ratio) 실시간 시각화
2. **메트릭 수집 & 알림**
   - Prometheus + Grafana 조합으로 DB, 애플리케이션, OS 메트릭을 수집/대시보드화
   - 임계값 초과 시 슬랙/이메일/문자 등으로 알림
3. **로그 분석**
   - 일반 쿼리 로그, 슬로우 쿼리 로그, 에러 로그 주기적 점검
   - Elasticsearch + Kibana 등을 활용한 중앙 집중형 로그 분석

---

## 요약

1. **면접 대비**
   - 인덱스/쿼리 튜닝, 트랜잭션 격리, 정규화/반정규화, 분산 DB 전략 등 주요 키워드를 숙지
   - 실제 예시(트러블슈팅 경험, 데드락 해결, 성능 튜닝 사례 등)를 이야기할 수 있으면 좋다
2. **트러블슈팅 시나리오**
   - 쿼리 성능 저하 → 실행 계획 분석, 인덱스 확인, 통계 갱신
   - 락 경합, 데드락 → 트랜잭션 범위 최소화, 재시도 처리, 락 획득 순서 일관성
3. **실무 응용**
   - 대규모 트래픽 환경에서 샤딩·레플리케이션·캐싱·아카이빙 등 고려
   - 마이크로서비스 DB 분산 시, 데이터 동기화 & 분산 트랜잭션 패턴 활용
   - 모니터링/로그 체계를 통해 사전 인지·분석 가능하도록 구축
