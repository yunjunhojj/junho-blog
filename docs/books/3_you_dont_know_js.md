# you don't know js

- 독서 기간 (2024.11.18 ~ ) / 스터디를 통해 진행
- 목적 : JS 기반으로 알고리즘 공부와 더불어 코딩 테스트 준비

## 목차 요약

- 1장 ~ 4장 자바스크립트 개념 / 1장 ~ 8장 스코프와 클로저
- 총 341 Page
- 연습하기는 스터디로 진행하진 않을 예정

## 스터디 진행

- 기간 : 11월 18일 부터 진행 ~ 약 2달 예상
- 날짜 : 매주 목요일, 10시부터 진행할 예정 (수정 가능성 있습니다)
- 한번 스터디때마다 2명이 발표를 하고, 간단한 퀴즈까지 내주시면 감사합니다. (퀴즈는 필수 아님)
  발표시간은 30분 이내로 하는 것이 적당할 듯 하고, 디스코드에서 진행합니다.
- 발표자 이외의 분들도 책을 읽어오면 좋을 것 같아요 (권장)
- 발표자 2명은 제가 랜덤 순서를 정하겠습니다.
- 요약 : 매주 하루, 2명 발표, 둘이 각각 1장(챕터) 발표
- 특이사항 : 짧은 챕터는 한명이 2장을 발표하겠습니다.

## Intro

<details>
  <summary>ch1 자바스크립트</summary>

자바스크립트에 마스터는 없습니다. 더 익숙해지고 친해질 수 있습니다.
이 책은 자바스크립트와 가까워지기 위한 여행이 될 것 입니다.

## 1.1 책에 대하여

자바스크립트 정복은 목적지가 아니라 바라봐야할 방향입니다.
조급하게 이 책을 후딱 읽고 끝낸다는 마음보다, 천천히 인내와 끈기를 갖고 읽기 바랍니다.

## 1.2 이름의 유래

자바 사용자에게 마케팅하기 위해 자바 + (가벼운)스크립트 언어 라는 의미로 만들어졌습니다.

TC39에서 지정하고 공식화된 명칭은 ECMAScript 입니다.
ES6는 ECMAScript 2015로도 불립니다. (ES6는 2015년에 나왔기 때문)

> 자바스크립트와 자바의 관계는 햄스터와 햄의 관계와 같습니다.

## 1.3 명세서

TC39는 js를 관리하는 운영 위원회입니다.
제안 단계는 0 ~ 4단계로 나뉩니다.

누구나 제안을 할 수 있지만, TC39의 승인을 받아야합니다. (https://github.com/tc39/proposals)

js는 버전이 없습니다. 공식적인 표준 js는 오직 하나입니다.

모든 브라우저, 디바이스 제조사는 단 하나뿐인 명세서를 기준으로 js 구현체를 만듭니다.

### JS를 지배하는 웹

JS 구현체를 만들 때 가장 중요시 되는 분야는 역시나 웹 환경입니다.

JS 엔진 제조사들은 js 구현체를 만들 때, 여러 상황에 대한 엣지 케이스를 고려하여 발전해 왔습니다.

이런 상황에서 JS 명세서가 업데이트 되었을 때, 엔진 제조사들은 명세서를 준수하도록 엔진을 업데이트 하거나 명세서 개정안을 자사 엔진에 반영하지 않겠다는 결정을 합니다.

만약 자사 엔진에 반영하지 않는다고 했을 때에는, TC39 위원회는 종종 기존 결정을 철회하고 명세서를 웹에 맞게 수정합니다. (ex. contains -> includes, flatten -> flat)

### JS지만 JS가 아닌 웹 전용 문법 (feat: alert)

```javascript
alert("Hello, World!");
```

이 코드는 **모든 웹** 전용 문법입니다. (alert는 브라우저에서만 동작합니다.)

브라우저 엔진, Node js 등과 같이 JS가 실행되는 환경은 전역 스코프에 API를 추가해 자체적으로 사용할 수 있는 기능을 제공합니다. (ex. alert)

alert 말고도 다양한 API가 있습니다. (ex. fetch, getCurrentLocation)

node js는 브라우저에서 사용할 수 없는 API를 제공합니다. (ex. fs, http)

우리가 자주 사용하는 console.log도 브라우저에서만 사용할 수 있는 API입니다.

이 처럼 console.log 코드를 본다면 호출은 JS지만, console.log는 명세서에 없는 웹 전용 문법이라는 것을 알 수 있습니다.

### 모든 코드가 JS인 것은 아닙니다.

개발자 도구의 경우 가장 중요시하는 것은 DX입니다. (Developer Experience)

그렇기 때문에 개발자 도구에서의 결과가 JS 명세서와 일치하지 않을 수 있습니다.

예를 들어 "전역 스코프 최상위 레벨에서 let과 const로 변수 여러 개를 선언했을 때 작동 방식"은 실제 명세서와는 다를 수 있습니다.

정확한 내용을 알고 싶다면 명세서를 참고해야합니다.

## 1.4 JS의 다양한 얼굴

프로그래밍에서는 "패러다임" 이라는 용어를 통해, 코드를 어떤식으로 작성할지에 대한 방법론을 제시합니다.

대표적인 패러다임은 다음과 같습니다.

- 절차적 프로그래밍 : 코드가 탑다운이면서 선현적으로 구조화, 이때 프로시저라 불리는 코드 단위에 미리 정해진 일련의 연산을 작성합니다.
- 객체지향 프로그래밍 : 코드를 클래스 단위로 구조화, 클래스는 데이터와 동작을 함께 묶어서 관리합니다.
- 함수형 프로그래밍 : 코드를 함수 단위로 구조화, 이때 함수는 순수하고 불변적이어야합니다. 또한 함수 자체가 값이 될 수 있습니다.

패러다임에 옳고 그름은 없습니다. 어떤 패러다임이든 적절한 상황이 있습니다.

특정 언어의 경우 지향하는 패러다임이 있지만 (C언어는 절차적, Java는 객체지향) JS는 다양한 패러다임을 지원합니다. 이를 다중 패러다임 언어라고 합니다.

## 1.5 하위 호환성과 상위 호환성

JS는 하위 호환성을 중요시합니다. (ex. ES6 코드는 ES5 엔진에서도 동작해야합니다.)

TC39 위원회는 새로운 기능을 추가할 때, 기존 코드와 충돌이 없도록 설계합니다. 그리고 "우리는 절대 웹을 망치지 않을 것이다" 라는 신념을 가지고 있습니다.

이에 장점만 있는 것은 아닙니다. 단점으로는 한번의 실수로 영원히 고치지 못하는 명세가 발생할 수 있습니다. 그만큼 엄격한 기준과 테스트를 필요로 합니다.

다만 예외적인 경우도 있습니다만, 매우 드물고 특별한 경우입니다.

이와 반대개념인 상위 호환성에 대해 알아보겠습니다.

일단 JS는 상위 호환성을 지향하지 않습니다. 상위 호환성을 지원하는 대표적인 예시는 HTML과 CSS입니다.

HTML과 CSS에서는 본질상 선언적이므로, 인식되지 않는 선언은 무시하고 넘어갑니다.

### 간극을 메우는 노력

JS는 상위 호환성을 보장하지 않기에 오래된 엔진에서는 최신 기능을 사용할 수 없습니다. 이런 문제를 해결하기 위해 방법이 있습니다.

- 폴리필 : ES6 이상의 기능을 ES5 이하에서 사용할 수 있도록 도와주는 코드 조각입니다. (ex. babel)
- 트랜스파일 : 코드를 변환하는 과정을 말합니다. (ex. babel)

바벨은 오래된 엔진에서도 최신 기능을 사용할 수 있도록 도와줍니다.

```javascript
// ES6
if (true) {
  let x = 2;
  console.log(x);
} else {
  let x = 3;
  console.log(x);
}
// let은 블록 스코프를 가지기 때문에 x는 블록 내부에서만 유효합니다.

// ES5 (바벨을 통해 변환된 코드)
var x$0, x$1;
if (true) {
  x$0 = 2;
  console.log(x);
} else {
  x$1 = 3;
  console.log(x);
}
```

그럼 그냥 옛날 방식으로 코딩하면 되지 않을까요? 그렇지 않습니다.

- ES6 이상의 기능은 코드를 더 명확하게 만들어줍니다.
- ES6 이상의 기능은 코드를 더 간결하게 만들어줍니다.
- ES6 이상의 기능은 코드를 더 안전하게 만들어줍니다.

이런 이유로 ES6 이상의 기능을 사용하는 것이 좋습니다. (다만, 폴리필과 트랜스파일을 통해 호환성을 지키는 것이 중요합니다.)

### 폴리필을 활용해서 극복하기

상위 호환성 문제가 새로운 문법이 아닌 근래에 추가되었지만, 아직 지원하지 않는 API 일 경우 폴리필을 사용할 수 있습니다.

```javascript
// finally 메서드는 ES6에 추가된 메서드입니다.
// 이 메서드는 Promise가 성공하든 실패하든 무조건 실행됩니다.

// 폴리필을 사용하지 않은 코드
promise
  .then(() => {
    // 성공
  })
  .catch(() => {
    // 실패
  })
  .finally(() => {
    // 무조건 실행
  });

// finally 메서드를 사용하기 위한 폴리필
if (typeof Promise.prototype.finally !== "function") {
  Promise.prototype.finally = function (callback) {
    return this.then(
      (value) => Promise.resolve(callback()).then(() => value),
      (reason) =>
        Promise.resolve(callback()).then(() => {
          throw reason;
        })
    );
  };
}
```

폴리필에 대한 정보는 ES-Shim Repository에서 확인할 수 있습니다.

## 1.6 인터프리터 이해하기

인터프리터 언어 vs 컴파일러 언어

- 인터프리터 언어 : 코드를 한 줄씩 읽어가며 실행합니다. (ex. JS, Python)
- 컴파일러 언어 : 코드를 한 번에 컴파일하고 실행합니다. (ex. C, C++)

장단점은 다음과 같습니다.

- 인터프리터 언어 : 빠른 개발, 느린 실행 (실행 시간이 오래 걸릴 수 있음, 최적화가 어려울 수 있음)
- 컴파일러 언어 : 느린 개발, 빠른 실행 (컴파일 시간이 오래 걸릴 수 있음)

인터프리터 언어는 한 줄씩 읽기 때문에, 만약 5번째 줄에서 오류가 발생하면 1 ~ 4번째 줄까지는 실행이 되고 오류를 발경하지 못합니다. 근데 이렇게 오류 발견을 미루는 것은 때에 따라서는 문제가 될 수 있습니다.

**파싱(Parsing)**

파싱이라는 단계를 거치는 언어도 있습니다. 만약 파싱 단계가 있다면 5번째 줄에 오류를 사전에 발견하여 오류를 수정할 수 있습니다.

이렇게 된다면 syntax error(혹은 static error)를 미리 발견할 수 있습니다.

파싱이 끝난 후에는 파싱 결과인 AST(Abstract Syntax Tree)를 바탕으로 실행 단계로 넘어갑니다. 이런 파싱의 역할로 인해 파싱하는 언어는 컴파일 언어라고 통용되기도 합니다.

그럼 JS도 파싱을 거치는 언어인데, 컴파일 언어일까요? 대답은 컴파일 언어에 가깝다 입니다.

js -> 파싱(추상 구문 트리) -> 컴파일(바이트 코드) -> 실행

**JS로 만든 코드의 실행 절차**

1. 작성된 코드는 바벨이 트랜스파일합니다. 이후 번들러(webpack)가 코드를 하나로 묶습니다. 이 결과를 JS 엔진으로 보냅니다.
2. JS 엔진은 코드를 실행하기 전에 파싱합니다. 이때 추상 구문 트리(AST)를 만듭니다.
3. AST를 바이트 코드로 컴파일합니다. 이때 최적화를 수행합니다. (JIT 컴파일)
4. JS 가상 머신이 바이트 코드를 실행합니다.

<!-- img 추가 -->
<img src="/img/books/js/v8-overview.png" alt="v8-overview" width="500" height="300"/>

이런 특징들 덕분에 문법 오류를 미리 발견할 수 있고, 프로그램을 더 빠르게 완성할 수 있습니다.

### 웹어셈블리 (WebAssembly)

JS로 작성한 코드를 얼마나 빠르게 실행할 수 있을까요? 이런 고민에서 웹어셈블리가 탄생했습니다.

처음에는 ASM.js라는 프로젝트로 시작되었습니다. ASM.js는 JS로 작성된 코드를 최적화하여 빠르게 실행할 수 있도록 도와줍니다.

이후에 WASM(WebAssembly)가 등장했습니다. JS기반 개발자가 아니라도 JS 엔진에서 사용될 코드를 쉽게 작성할 수 있도록 도와줍니다. 특징으로는 파싱과 컴파일 단계를 거치지 않고, 바이트 코드로 바로 실행할 수 있습니다.

WASM은 웹을 위한 기술은 아닙니다. 다른 어떤 언어도 컴파일러만 있다면 WASM을 사용할 수 있습니다.

JS를 WASM이 대체하지는 않습니다. WASM은 JS와 함께 사용할 수 있는 기술입니다.

## 1.7 엄격 모드

엄격 모드는 JS의 버그를 줄이기 위해 만들어졌습니다.

엄격 모드는 다음과 같은 특징이 있습니다. (use strict)

- 선언되지 않은 변수를 사용하면 ReferenceError가 발생합니다.
- 함수의 매개변수 이름이 중복되면 SyntaxError가 발생합니다.
- with 문을 사용하면 SyntaxError가 발생합니다.
- eval 함수를 사용하면 SyntaxError가 발생합니다.

```javascript
// "use strict"; 는 함수 단위로도 사용할 수 있습니다. 점진적으로 적용할 때 사용할 수 있습니다.

function foo() {
  // 공백 혹은 주석만 use strict 위에 있을 수 있습니다.
  "use strict";
  x = 10; // ReferenceError: x is not defined
}
```

## 1.8 요약

- JS는 ECMAScript 명세서를 따르는 언어입니다.
- TC39 위원회가 명세서를 관리합니다.
- 브라우저를 비롯해 Node.js, Deno 등 다양한 환경에서 JS를 사용할 수 있습니다.

- JS는 다중 패러다임 언어입니다.
- 객제지향, 함수형, 절차적 프로그래밍을 지원합니다.

- JS는 컴파일 처리되는 언어입니다. (파싱, 컴파일, 실행 단계를 거칩니다.)

</details>
